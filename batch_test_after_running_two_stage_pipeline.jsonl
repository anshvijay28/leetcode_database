{"custom_id": "qid-1-chunk-1", "method": "POST", "url": "/v1/embeddings", "body": {"input": "1. Problem Essence\n\nThis problem asks you to find two distinct indices i and j in an integer array such that nums[i] + nums[j] equals a given target, knowing there is exactly one such pair. The output is the pair of indices in any order, and you may not reuse the same element twice. The core challenge is to locate this pair efficiently without checking all O(n\u00b2) possible pairs, especially under the follow-up requirement to do better than quadratic time.", "model": "text-embedding-3-large", "encoding_format": "float", "dimensions": 1024}}
{"custom_id": "qid-1-chunk-2", "method": "POST", "url": "/v1/embeddings", "body": {"input": "2. Data Structures Used\n\nAll solutions treat the input as a simple array (Python list, Java/C++ array or vector) and iterate over it with indices. The optimal solutions use a hash table (Python dict, Java HashMap, C++ unordered_map) that maps a value to its index. This hash map enables O(1) average-time lookup of the complement value (target - current), trading additional O(n) space to avoid nested loops. \n\nIn the two-pass hash map variants, the map is fully populated with value \u2192 index in a first pass, then queried in a second pass to check for complements with a different index. In the one-pass variants, the map is built incrementally while iterating: for each element, they first look up its complement in the map, and only then insert the current element. The brute-force solution uses only loop variables and no auxiliary data structure beyond the array itself.", "model": "text-embedding-3-large", "encoding_format": "float", "dimensions": 1024}}